/* Copyright (c) 2008-2025 the MRtrix3 contributors.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * Covered Software is provided under this License on an "as is"
 * basis, without warranty of any kind, either expressed, implied, or
 * statutory, including, without limitation, warranties that the
 * Covered Software is free of defects, merchantable, fit for a
 * particular purpose or non-infringing.
 * See the Mozilla Public License v. 2.0 for more details.
 *
 * For more details, see http://www.mrtrix.org/.
 */

#include "algo/threaded_loop.h"
#include "command.h"
#include "image.h"
#include "stride.h"
#include "transform.h"

#include <filesystem>

using namespace MR;
using namespace App;

// clang-format off
void usage() {

  AUTHOR = "J-Donald Tournier (jdtournier@gmail.com)";

  SYNOPSIS = "Create an initial warp image, representing an identity transformation";

  DESCRIPTION
  + "This is useful to obtain the warp fields from other normalisation applications,"
    " by applying the transformation of interest to the warp field generated by this command."

  + "The image generated is a 4D image"
    " with the same spatial characteristics as the input template image."
    " It contains 3 volumes,"
    " with each voxel containing its own x,y,z coordinates.";

  EXAMPLES
  + Example("Create three separate NIfTI images, for each of X,Y,Z components",
            "warpinit template.mif warp-'[]'.nii",
            "By utilising the MRtrix multi-file numbering syntax,"
            " the command can natively produce three separate images,"
            " which may be useful to create images suitable for use in some registration software");

  ARGUMENTS
  + Argument ("template", "the input template image.").type_image_in()
  + Argument ("warp", "the output warp image.").type_image_out();

}
// clang-format on

void run() {
  const std::filesystem::path input_image_path{argument[0]};
  const std::filesystem::path output_image_path{argument[1]};

  auto header = Header::open(input_image_path);

  header.datatype() = DataType::Float32;
  header.ndim() = 4;
  header.size(3) = 3;
  Stride::set(header, Stride::contiguous_along_axis(3, header));

  auto warp = Image<float>::create(output_image_path, header);

  Transform transform(header);

  auto func = [&transform](Image<float> &image) {
    Eigen::Vector3d voxel_pos((float)image.index(0), (float)image.index(1), (float)image.index(2));
    Eigen::Vector3f scanner_pos = (transform.voxel2scanner * voxel_pos).cast<float>();
    for (auto l = Loop(3)(image); l; ++l)
      image.value() = scanner_pos[image.index(3)];
  };

  ThreadedLoop("generating identity warp", warp, 0, 3).run(func, warp);
}
