#!/usr/bin/env python

# Script for performing diffusion eddy current / motion correction using FSL eddy

# This script is a light wrapper around FSL's eddy tool, for performing correct of inter-volume motion and eddy current-induced distortions in a diffusion image series in cases where no image information is available for performing inhomogeneity distortion correction (e.g. reversed phase-encode image pair(s) or field map).

# Order of input arguments is:
# * Phase encode direction: This can be an axis number (0-2), or one of the following: lr, rl, ap, pa, is, si
# * Name of image series to be corrected
# * Name of output corrected image series


import os, sys
from distutils.version import LooseVersion
import lib.app

from lib.binaryInPath   import binaryInPath
from lib.errorMessage   import errorMessage
from lib.getFSLEddyPath import getFSLEddyPath
from lib.getFSLSuffix   import getFSLSuffix
from lib.getFSLVersion  import getFSLVersion
from lib.getHeaderInfo  import getHeaderInfo
from lib.getPEDir       import getPEDir
from lib.printMessage   import printMessage
from lib.runCommand     import runCommand
from lib.warnMessage    import warnMessage

lib.app.initCitations([ 'eddy/topup', 'FSL' ])
lib.app.initParser('Perform motion correction and eddy-current distortion correction of a DWI series using FSL eddy.')
lib.app.parser.add_argument('pe_dir' ,   help='The phase encode direction / axis; can be a signed axis number (e.g. -0, 1, +2) or a code (e.g. AP, LR, IS)')
lib.app.parser.add_argument('series',    help='The image series to be corrected')
lib.app.parser.add_argument('output',    help='The output corrected image series')
lib.app.parser.add_argument('-cuda',     help='Use the CUDA version of eddy', action='store_true', default=False)
lib.app.initialise()

eddy_cmd = getFSLEddyPath(lib.app.args.cuda)
fsl_version = getFSLVersion()
fsl_suffix = getFSLSuffix()

# Figure out the phase encode direction
PE_dir = getPEDir(lib.app.args.pe_dir)

# Convert all input images into MRtrix format and store in temprary directory first;
#   that way getHeaderInfo() can be run multiple times without having to repeatedly parse e.g. DICOM data
runCommand('mrconvert ' + lib.app.args.series    + ' ' + os.path.join(lib.app.tempDir, 'series.mif'))

lib.app.gotoTempDir()

# Verify that input image is valid
series_dim = getHeaderInfo ('series.mif', 'dimensions').split()
if len(series_dim) != 4:
  errorMessage ('Input image should be a 4D volume series')
grad = getHeaderInfo ('series.mif', 'dwgrad')
if not grad:
  errorMessage ('No diffusion gradient encoding found in input file')

# Get the axis strides from the input series, so the output image can be modified to match
stride = getHeaderInfo ('series.mif', 'stride')
stride_option = ' -stride ' + stride.replace(' ', ',')

# Convert the input files as necessary for FSL tools
runCommand('mrconvert series.mif series_before.nii -stride +1,+2,+3,+4')

# Construct a configuration file
printMessage('Creating phase-encoding configuration file')
config_file = open('config.txt', 'w')
config_line = [ '0', '0', '0', '0.1' ]
if PE_dir[1]:
  config_line[PE_dir[0]] = '-1'
else:
  config_line[PE_dir[0]] = '1'
config_file.write(' '.join (config_line) + '\n')
config_file.close()

# Create the diffusion gradient table in FSL format
# Make sure the strides are identical to the image actually being passed to eddy before exporting the gradient table
runCommand('mrconvert series.mif - -stride +1,+2,+3,+4 | mrinfo - -export_grad_fsl bvecs bvals')
    
# Use the initial corrected image series from applytopup to derive a processing mask for eddy
runCommand('dwi2mask series.mif - | maskfilter - dilate - | mrconvert - mask.nii -datatype float32')
  
# Generate configuration file for eddy - index referring to PE and bandwidth for each volume
# Every volume has identical acquisition parameters in this particular use case
num_volumes = int(series_dim[3])
indices = ''
for volume in range(0, num_volumes):
  indices = indices + '1 '
with open('indices.txt', 'w') as index_file:
  index_file.write(indices);
  
# Run eddy
runCommand(eddy_cmd + ' --imain=series_before.nii --mask=mask.nii --index=indices.txt --acqp=config.txt --bvecs=bvecs --bvals=bvals --out=series_after')

result_path = 'result' + os.path.splitext(lib.app.args.output)[1]
  
# Convert the resulting volume to the output image, and re-insert the diffusion encoding
# Note that if FSL < 5.0.9, the script uses the diffusion encoding from the original DWI volumes,
#   i.e. no reorientation of diffusion gradient vectors is performed.
if LooseVersion(fsl_version) >= LooseVersion('5.0.9') and os.path.exists('series_after.eddy_rotated_bvecs'):
  runCommand('mrconvert series_after' + fsl_suffix + ' ' + result_path + stride_option + ' -fslgrad series_after.eddy_rotated_bvecs bvals')
else:
  warnMessage('FSL eddy v' + fsl_version + ' does not rotate the gradient vectors. Update to FSL 5.0.9 or rotate the bvecs file manually.')
  runCommand('mrconvert series_after' + fsl_suffix + ' ' + result_path + stride_option + ' -fslgrad bvecs bvals')
    
lib.app.moveFileToDest(result_path, lib.app.args.output)
lib.app.complete()

