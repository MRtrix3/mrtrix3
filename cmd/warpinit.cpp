/*
    Copyright 2008 Brain Research Institute, Melbourne, Australia

    Written by J-Donald Tournier, 27/06/08.

    This file is part of MRtrix.

    MRtrix is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MRtrix is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with MRtrix.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "command.h"
#include "image/buffer.h"
#include "image/voxel.h"
#include "image/stride.h"
#include "image/transform.h"
#include "image/threaded_loop.h"


using namespace MR;
using namespace App;

void usage ()
{
  DESCRIPTION
  + "create an initial warp image, representing an identity transformation. "
    "This is useful to obtain the warp fields from other normalisation "
    "applications, by applying the transformation of interest to the the "
    "warp field generated by this program." 

  + "The image generated is 4D image with the same spatial characteristics as "
    "the input template image. It contains 3 volumes, with each voxel containing "
    "its own x,y,z coordinates.";

  ARGUMENTS
  + Argument ("template", "the input template image.").type_image_in ()
  + Argument ("warp", "the output warp image.").type_image_out ();
}


class write_coordinates {
  public:
    template <class InfoType>
      write_coordinates (const InfoType& in) :
        transform (in) { }

    template <class VoxelType>
      void operator() (VoxelType& vox) const {
        Point<float> coord = transform.voxel2scanner (Point<float> (vox[0], vox[1], vox[2]));
        vox.value() = coord[0];
        ++vox[3];
        vox.value() = coord[1];
        ++vox[3];
        vox.value() = coord[2];
        vox[3] -= 2;
      }

  private:
    const Image::Transform transform;
};


void run ()
{
  Image::Header header (argument[0]);

  header.datatype() = DataType::Float32;
  header.set_ndim (4);
  header.dim(3) = 3;
  Image::Stride::set (header, Image::Stride::contiguous_along_axis (3));

  Image::Buffer<float> warp_buffer (argument[1], header);
  Image::Buffer<float>::voxel_type warp_vox (warp_buffer);

  Image::ThreadedLoop ("initialising warp image...", warp_vox, 1, 0, 3)
    .run (write_coordinates (warp_vox), warp_vox);
}
