#!/usr/bin/env python



# Since we're going to capture everything after the colon character and "hide" it from argparse,
#   we need to store the contents from there in a global so as for it to be accessible from execute()
cmdsplit = [ ]

def usage(cmdline): #pylint: disable=unused-variable
  global cmdsplit
  cmdline.setAuthor('Robert E. Smith (robert.smith@florey.edu.au) and David Raffelt (david.raffelt@florey.edu.au)')
  cmdline.setSynopsis('Perform some arbitrary processing step for each of a set of inputs')
  cmdline.addDescription('EXAMPLE USAGE: \n' \
                             '  $ foreach folder/*.mif : mrinfo IN   \n'
                             '  will run mrinfo for each .mif file in "folder"')
  cmdline.addDescription('AVAILABLE SUBSTITUTIONS: \n' \
                             '  IN:   The full matching pattern, including leading folders. For example, if the target list contains a file "folder/image.mif", any occurrence of "IN" will be substituted with "folder/image.mif".' \
                             '  NAME: The basename of the matching pattern. For example, if the target list contains a file "folder/image.mif", any occurrence of "NAME" will be substituted with "image.mif".' \
                             '  PRE:  The prefix of the basename. For example, if the target list contains a file "folder/image.mif", any occurrence of "PRE" will be substituted with "image".' \
                             '  UNI:  The unique part of the input after removing any common prefix and common suffix. For example, if the target list contains files: "folder/001dwi.mif", "folder/002dwi.mif", "folder/003dwi.mif", any occurrence of "UNI" will be substituted with "001", "002", "003".')
  cmdline.addDescription('Note that due to a limitation of the Python argparse module, any command-line options provided to the foreach script must appear before any inputs are specified.')
  cmdline.addDescription('Such command-line options provided before the list of inputs and colon separator will be interpreted by the foreach script; any command-line options provided after this colon will form part of the input to the executed command.')
  cmdline.add_argument('inputs',  help='Each of the inputs for which processing should be run', nargs='+')
  cmdline.add_argument('colon',   help='Colon symbol (":") delimiting the foreach inputs & command-line options from the actual command to be executed', type=str, choices=[':'])
  cmdline.add_argument('command', help='The command string to run for each input, containing any number of substitutions listed in the Description section', type=str)

  # Usage of foreach needs to be handled slightly differently here:
  # We want argparse to parse only the contents of the command-line before the colon symbol,
  #   as these are the items that pertain to the invocation of the foreach script;
  #   anything after the colon should instead form a part of the command that
  #   foreach is responsible for executing
  try:
    index = next(i for i,s in enumerate(sys.argv) if s == ':')
    try:
      cmdsplit = sys.argv[index+1:]
      sys.argv = sys.argv[:index+1]
      sys.argv.append(' '.join(cmdsplit))
    except IndexError:
      sys.stderr.write('Erroneous usage: No command specified (colon separator cannot be the last entry provided)\n')
      sys.exit(0)
  except StopIteration:
    if len(sys.argv) > 2:
      sys.stderr.write('Erroneous usage: A colon must be used to separate foreach inputs from the command to be executed\n')
      sys.exit(0)







import threading

# These need to be globals in order to be accessible from execute_parallel()
job_index = 0
lock = threading.Lock()
stop = False





def execute(): #pylint: disable=unused-variable
  from mrtrix3 import MRtrixError, run
  global cmdsplit

  app.var(str(app.args.inputs))
  app.var(app.args.command)
  app.var(cmdsplit)

  common_prefix = os.path.commonprefix(app.args.inputs)
  common_suffix = os.path.commonprefix([i[::-1] for i in app.args.inputs])[::-1]
  app.var(common_prefix, common_suffix)

  keylist = [ 'IN', 'NAME', 'PRE', 'UNI' ]

  for entry in cmdsplit:
    if os.path.exists(entry):
      keys_present = [ key for key in keylist if key in entry ]
      if keys_present:
        app.warn('Performing text substitution of ' + str(keys_present) + ' within command: "' + entry + '"; but the original text exists as a path on the file system... is this a problematic filesystem path?')

  try:
    next(entry for entry in cmdsplit if any(key for key in keylist if key in entry))
  except StopIteration:
    raise MRtrixError('None of the unique foreach keys ' + str(keylist) + ' appear in command string "' + app.args.command + '"; no substitution can occur')

  class Entry(object):
    def __init__(self, input_text):
      self.sub_in = input_text
      self.sub_name = os.path.basename(input_text)
      self.sub_pre = self.sub_name.split('.')[0]
      self.sub_uni = input_text[len(common_prefix):-len(common_suffix)]

      self.substitutions = { 'IN': self.sub_in, 'NAME': self.sub_name, 'PRE': self.sub_pre, 'UNI': self.sub_uni }
      app.var(input_text, self.substitutions)

      self.cmd = [ ]
      for entry in cmdsplit:
        for (key, value) in self.substitutions.items():
          entry = entry.replace(key, value)
        if ' ' in entry:
          entry = '"' + entry + '"'
        self.cmd.append(entry)
      app.var(self.cmd)

      self.outputtext = None
      self.returncode = None

  jobs = [ ]
  for i in app.args.inputs:
    jobs.append(Entry(i))

  parallel = app.numThreads is not None and app.numThreads > 1



  def progressString():
    s = str(sum([ 1 if job.returncode is not None else 0 for job in jobs ])) + \
        '/' + \
        str(len(jobs)) + \
        ' jobs completed ' + \
        ('across ' + str(app.numThreads) + ' threads' if parallel else 'sequentially')
    fail_count = sum([ 1 if job.returncode else 0 for job in jobs ])
    if fail_count:
      s += ' (' + str(fail_count) + ' errors)'
    return s

  progress = app.progressBar(progressString(), len(jobs))

  def execute_parallel():
    global job_index, lock, stop
    while not stop:
      my_job = None
      with lock:
        if job_index < len(jobs):
          my_job = jobs[job_index]
          job_index += 1
          stop = job_index == len(jobs)
      if not my_job:
        return
      try:
        result = run.command(' '.join(my_job.cmd), True) # Run in shell mode
        my_job.outputtext = result.stdout + result.stderr
        my_job.returncode = 0
      except run.MRtrixCmdError as e:
        my_job.outputtext = str(e)
        my_job.returncode = e.returncode
      except Exception as e: # pylint: disable=broad-except
        my_job.outputtext = str(e)
        my_job.returncode = 1
      with lock:
        progress.increment(progressString())

  if parallel:
    threads = [ ]
    for i in range (1, app.numThreads):
      t = threading.Thread(target=execute_parallel)
      t.start()
      threads.append(t)
    execute_parallel()
    for t in threads:
      t.join()

  else:
    for job in jobs:
      try:
        result = run.command(' '.join(job.cmd), True) # Run in shell mode
        job.outputtext = result.stdout + result.stderr
        job.returncode = 0
      except run.MRtrixCmdError as e:
        job.outputtext = str(e)
        job.returncode = e.returncode
      except Exception as e: # pylint: disable=broad-except
        job.outputtext = str(e)
        job.returncode = 1
      progress.increment(progressString())

  progress.done()

  assert all([ job.returncode is not None for job in jobs ])
  fail_count = sum([ 1 if job.returncode else 0 for job in jobs ])
  app.var(fail_count)
  if fail_count:
    app.warn(str(fail_count) + ' of ' + str(len(jobs)) + ' jobs did not complete successfully')
    if fail_count > 1:
      app.warn('Outputs from failed commands:')
      sys.stderr.write(app.execName + ':\n')
    else:
      app.warn('Output from failed command:')
    for job in jobs:
      if job.returncode:
        if job.outputtext:
          app.warn('For input "' + job.sub_in + '" (returncode = ' + str(job.returncode) + '):')
          for line in job.outputtext.splitlines():
            sys.stderr.write(' ' * (len(app.execName)+2) + line + '\n')
        else:
          app.warn('No output from command for input "' + job.sub_in + '" (return code = ' + str(job.returncode) + ')')
        if fail_count > 1:
          sys.stderr.write(app.execName + ':\n')
    raise MRtrixError(str(fail_count) + ' of ' + str(len(jobs)) + ' jobs did not complete successfully')

  if app.verbosity > 1:
    if any(job.outputtext for job in jobs):
      sys.stderr.write(app.execName + ':\n')
      for job in jobs:
        if job.outputtext:
          app.console('Output of command for input "' + job.sub_in + '":')
          for line in job.outputtext.splitlines():
            sys.stderr.write(' ' * (len(app.execName)+2) + line + '\n')
        else:
          app.console('No output from command for input "' + job.sub_in + '"')
        sys.stderr.write(app.execName + ':\n')
    else:
      app.console('No output from command for any inputs')

  app.console('Script reported successful completion for all inputs')







# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys
lib_folder = os.path.realpath(os.path.join(os.path.dirname(os.path.realpath(inspect.getfile(inspect.currentframe()))), os.pardir, 'lib'))
if not os.path.isdir(lib_folder):
  sys.stderr.write('Unable to locate MRtrix3 Python libraries')
  sys.exit(1)
sys.path.insert(0, lib_folder)
# Execute the script
from mrtrix3 import app
app.execute()
