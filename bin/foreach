#!/usr/bin/env python



def usage(cmdline): #pylint: disable=unused-variable
  cmdline.setAuthor('Robert E. Smith (robert.smith@florey.edu.au) and David Raffelt (david.raffelt@florey.edu.au)')
  cmdline.setSynopsis('Perform some arbitrary processing step for each of a set of inputs')
  cmdline.addDescription('EXAMPLE USAGE: \n' \
                             '  $ foreach folder/*.mif "mrinfo IN"   \n'
                             '  will run mrinfo for each .mif file in "folder"')
  cmdline.addDescription('AVAILABLE SUBSTITUTIONS: \n' \
                             '  IN:   The full matching pattern, including leading folders. For example, if the target list contains a file "folder/image.mif", any occurrence of "IN" will be substituted with "folder/image.mif".' \
                             '  NAME: The basename of the matching pattern. For example, if the target list contains a file "folder/image.mif", any occurrence of "NAME" will be substituted with "image.mif".' \
                             '  PRE:  The prefix of the basename. For example, if the target list contains a file "folder/image.mif", any occurrence of "PRE" will be substituted with "image".' \
                             '  UNI:  The unique prefix of the basename after removing the common suffix. For example, if the target list contains files: "folder/001dwi.mif", "folder/002dwi.mif", "folder/003dwi.mif", any occurrence of "UNI" will be substituted with "001", "002", "003".')
  cmdline.add_argument('inputs',  help='Each of the inputs for which processing should be run', nargs='+')
  cmdline.add_argument('command', help='The command string to run for each input, containing the substitutions listed in the Description section', type=str)





import threading

# These need to be globals in order to be accessible from execute_parallel()
job_index = 0
lock = threading.Lock()
stop = False





def execute(): #pylint: disable=unused-variable
  import shlex
  from mrtrix3 import MRtrixException, run

  app.var(str(app.args.inputs))
  app.var(app.args.command)

  common_prefix = os.path.commonprefix(app.args.inputs)
  common_suffix = os.path.commonprefix([i[::-1] for i in app.args.inputs])[::-1]
  app.var(common_prefix, common_suffix)

  cmdsplit = shlex.split(app.args.command)
  app.var(cmdsplit)

  for entry in cmdsplit:
    if os.path.exists(entry):
      keys_present = [ key for key in [ 'IN', 'NAME', 'PRE', 'UNI' ] if key in entry ]
      if keys_present:
        app.warn('Performing text substitution of ' + str(keys_present) + ' within command: "' + entry + '"; but the original text exists as a path on the file system... is this a problematic filesystem path?')

  class Entry(object):
    def __init__(self, input_text):
      self.sub_in = input_text
      self.sub_name = os.path.basename(input_text)
      self.sub_pre = self.sub_name.split('.')[0]
      self.sub_uni = self.sub_name[:-len(common_suffix)]

      self.substitutions = { 'IN': self.sub_in, 'NAME': self.sub_name, 'PRE': self.sub_pre, 'UNI': self.sub_uni }
      app.var(input, self.substitutions)

      self.cmd = [ ]
      for entry in cmdsplit:
        for (key, value) in self.substitutions.items():
          entry = entry.replace(key, value)
        if ' ' in entry:
          entry = '"' + entry + '"'
        self.cmd.append(entry)
      app.var(self.cmd)

      self.outputtext = None
      self.returncode = None

  jobs = [ ]
  for i in app.args.inputs:
    jobs.append(Entry(i))

  parallel = app.numThreads is not None and app.numThreads > 1

  progress = app.progressBar('Executing ' + str(len(jobs)) + ' jobs ' + ('across ' + str(app.numThreads) + ' threads' if parallel else 'sequentially'), len(jobs))

  def execute_parallel():
    global job_index, lock, stop
    while not stop:
      my_job = None
      with lock:
        if job_index < len(jobs):
          my_job = jobs[job_index]
          job_index += 1
          stop = job_index == len(jobs)
      if not my_job:
        return
      try:
        if any([ 'foreach' in s for s in my_job.cmd ]):
          raise run.MRtrixCmdException(my_job.cmd, 1, '', 'Running for foreach')
        result = run.command(' '.join(my_job.cmd))
        my_job.outputtext = result.stdout + result.stderr
        my_job.returncode = 0
      except run.MRtrixCmdException as e:
        my_job.outputtext = str(e)
        my_job.returncode = e.returncode
      except Exception as e: # pylint: disable=broad-except
        my_job.outputtext = str(e)
        my_job.returncode = 1
      with lock:
        progress.increment()

  if parallel:
    threads = [ ]
    for i in range (1, app.numThreads):
      t = threading.Thread(target=execute_parallel)
      t.start()
      threads.append(t)
    execute_parallel()
    for t in threads:
      t.join()

  else:
    for job in jobs:
      try:
        if any([ 'foreach' in s for s in job.cmd ]):
          raise run.MRtrixCmdException(job.cmd, 1, '', 'Running for foreach')
        result = run.command(' '.join(job.cmd))
        job.outputtext = result.stdout + result.stderr
        job.returncode = 0
      except run.MRtrixCmdException as e:
        job.outputtext = str(e)
        job.returncode = e.returncode
      except Exception as e: # pylint: disable=broad-except
        job.outputtext = str(e)
        job.returncode = 1
      progress.increment()

  progress.done()

  assert all([ job.returncode is not None for job in jobs ])
  fail_count = sum([ 1 if job.returncode else 0 for job in jobs ])
  app.var(fail_count)
  if fail_count:
    app.warn(str(fail_count) + ' of ' + str(len(jobs)) + ' jobs did not complete successfully')
    if fail_count > 1:
      app.warn('Outputs from failed commands:')
      sys.stderr.write(app.execName + ':\n')
    else:
      app.warn('Output from failed command:')
    for job in jobs:
      if job.returncode:
        if job.outputtext:
          app.warn('For input "' + job.sub_in + '" (returncode = ' + str(job.returncode) + '):')
          for line in job.outputtext.splitlines():
            sys.stderr.write(' ' * (len(app.execName)+2) + line + '\n')
        else:
          app.warn('No output from command for input "' + job.sub_in + '" (return code = ' + str(job.returncode) + ')')
        if fail_count > 1:
          sys.stderr.write(app.execName + ':\n')
    raise MRtrixException(str(fail_count) + ' of ' + str(len(jobs)) + ' jobs did not complete successfully')

  if app.verbosity > 1:
    if any(job.outputtext for job in jobs):
      sys.stderr.write(app.execName + ':\n')
      for job in jobs:
        if job.outputtext:
          app.console('Output of command for input "' + job.sub_in + '":')
          for line in job.outputtext.splitlines():
            sys.stderr.write(' ' * (len(app.execName)+2) + line + '\n')
        else:
          app.console('No output from command for input "' + job.sub_in + '"')
        sys.stderr.write(app.execName + ':\n')
    else:
      app.console('No output from command for any inputs')

  app.console('Command reported successful completion for all inputs')







# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys
lib_folder = os.path.realpath(os.path.join(os.path.dirname(os.path.realpath(inspect.getfile(inspect.currentframe()))), os.pardir, 'lib'))
if not os.path.isdir(lib_folder):
  sys.stderr.write('Unable to locate MRtrix3 Python libraries')
  sys.exit(1)
sys.path.insert(0, lib_folder)
# Execute the script
from mrtrix3 import app
app.execute()
