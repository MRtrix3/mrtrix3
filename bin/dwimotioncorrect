#!/usr/bin/env python

#   MOTION CORRECTION FOR DWI VOLUME SERIES
#
#   This script performs volume-to-series and slice-to-series registration
#   of diffusion-weighted images for motion correction in the brain.
#
#   Author:  Daan Christiaens
#            King's College London
#            daan.christiaens@kcl.ac.uk
#

#   __________ Initialisation __________

# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys, subprocess
p = subprocess.Popen(['which', 'mrinfo'], stdout=subprocess.PIPE)
line = p.stdout.readline().decode().strip()
lib_folder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(line)[0], os.pardir, 'lib')))
if not os.path.isdir(lib_folder):
    sys.stderr.write('Unable to locate MRtrix3 Python libraries')
    sys.exit(1)
sys.path.insert(0, lib_folder)
from mrtrix3 import app, fsl, image, path, run


app.init('Daan Christiaens (daan.christiaens@kcl.ac.uk)',
         'Perform motion correction for a DWI volume series')

app.cmdline.add_argument('input',  help='The input image series to be corrected')
app.cmdline.add_argument('output', help='The output multi-shell SH coefficients')

options = app.cmdline.add_argument_group('Options for the dwimotioncorrect script')
options.add_argument('-mask', help='Manually provide a mask image for motion correction')
options.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
options.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')
options.add_argument('-niter', help='Number of epochs (default = 3)')
options.add_argument('-lmax', help='SH basis order per shell (default = 0,4,4,...)')
options.add_argument('-rlmax', help='Reduced basis order per component for registration (default = 2,2,0)')
options.add_argument('-reg', help='Regularization for dwirecon (default = 0.001)')
options.add_argument('-zreg', help='Regularization for dwirecon (default = 0.01)')
options.add_argument('-lbreg', help='Laplace-Beltrami regularization for SHARD (default = 0)')
options.add_argument('-mb', help='Multiband factor (default = 1)')
options.add_argument('-sorder', help='Slice order (default = 2,1, for odd-even)')
options.add_argument('-sspwidth', help='Slice thickness for Gaussian SSP (default = 1)')
options.add_argument('-sspfile', help='Slice sensitivity profile as vector')
options.add_argument('-or_loss', help='Outlier rejection loss function (default = softl1)')
options.add_argument('-matchintensity', help='Activate "slice" or "full" intensity matching (default = off)')
options.add_argument('-fieldmap', help='B0 field map for distortion correction')
options.add_argument('-fieldidx', help='Index of volume to which field map is aligned (default = 0)')
options.add_argument('-pe_table', help='Phase encoding table in MRtrix format')
options.add_argument('-pe_eddy', nargs=2, help='Phase encoding table in FSL acqp/index format')
options.add_argument('-sliceweights', help='Import fixed slice weights')
options.add_argument('-export_motion', help='Export rigid motion parameters')
options.add_argument('-export_weights', help='Export slice weights')
app.cmdline.flagMutuallyExclusiveOptions( [ 'grad', 'fslgrad' ] )
app.parse()


grad_import_option = ''
if app.args.grad:
    grad_import_option = ' -grad ' + path.fromUser(app.args.grad, True)
elif app.args.fslgrad:
    grad_import_option = ' -fslgrad ' + path.fromUser(app.args.fslgrad[0], True) + ' ' + path.fromUser(app.args.fslgrad[1], True)

pe_import_option = ''
if app.args.pe_table:
    pe_import_option = ' -import_pe_table ' + path.fromUser(app.args.pe_table, True)
elif app.args.pe_eddy:
    pe_import_option = ' -import_pe_eddy ' + path.fromUser(app.args.pe_eddy[0], True) + ' ' + path.fromUser(app.args.pe_eddy[1], True)


app.checkOutputPath(app.args.output)
if app.args.export_motion:
    app.checkOutputPath(app.args.export_motion)
if app.args.export_weights:
    app.checkOutputPath(app.args.export_weights)


app.makeTempDir()

run.command('mrconvert ' + path.fromUser(app.args.input, True) + ' ' + path.toTemp('in.mif', True) + grad_import_option + pe_import_option)
if app.args.mask:
    run.command('mrconvert ' + path.fromUser(app.args.mask, True) + ' ' + path.toTemp('mask.mif', True))
if app.args.fieldmap:
    run.command('mrconvert ' + path.fromUser(app.args.fieldmap, True) + ' ' + path.toTemp('field.mif', True))

app.gotoTempDir()


# Make sure it's actually a DWI that's been passed
header = image.Header('in.mif')
dwi_sizes = header.size()
if len(dwi_sizes) != 4:
    app.error('Input image must be a 4D image')
DW_scheme = image.mrinfo('in.mif', 'dwgrad').split('\n')
if len(DW_scheme) != int(dwi_sizes[3]):
    app.error('Input image does not contain valid DW gradient scheme')

# Check PE table if field map is passed.
if app.args.fieldmap:
    PE_scheme = image.mrinfo('in.mif', 'petable').split('\n')
    if len(PE_scheme) != int(dwi_sizes[3]):
        app.error('Input image does not contain valid phase encoding scheme')


# Generate a brain mask if required, or check the mask if provided
if app.args.mask:
    if not image.match(header, 'mask.mif', max_dim=3):
        app.error('Provided mask image does not match input DWI')
else:
    run.command('dwi2mask in.mif mask.mif')


# Image dimensions
dims = list(map(int, header.size()))
vox = list(map(float, header.spacing()))
vu = round((vox[0]+vox[1])/2., 1)
shells = [s.split('.')[0] for s in image.mrinfo('in.mif', 'shell_bvalues').split()]


# Set lmax
lmax = [0,] + [4,]*(len(shells)-1)
if app.args.lmax:
    lmax = [int(l) for l in app.args.lmax.split(',')]
if len(lmax) != len(shells):
    app.error('No. lmax must match no. shells.')

rlmax = [2,2,0]
if app.args.rlmax:
    rlmax = [int(l) for l in app.args.rlmax.split(',')]
if len(rlmax) > len(lmax) or max(rlmax) > max(lmax):
    app.error('-rlmax invalid.')

# Regularization options
reg_option = ''
if app.args.reg:
    reg_option += ' -reg ' + app.args.reg
if app.args.zreg:
    reg_option += ' -zreg ' + app.args.zreg

# SSP option
ssp_option = ''
if app.args.sspfile:
    run.command('cp ' + path.fromUser(app.args.sspfile, True) + ' ssp.txt')
    ssp_option = ' -ssp ssp.txt'
elif app.args.sspwidth:
    ssp_option = ' -ssp ' + app.args.sspwidth

# Initialise radial basis with RF per shell.
rfs = []
for k, l in enumerate(lmax):
    fn = 'rf'+str(k+1)+'.txt'
    with open(fn, 'w') as f:
        for s in range(len(shells)):
            if k==s:
                f.write(' '.join(['1',]*(l//2+1)) + '\n')
            else:
                f.write(' '.join(['0',]*(l//2+1)) + '\n')
    rfs += [fn,]

redrfs = ['redrf'+str(k+1)+'.txt' for k in range(len(rlmax))]

# Force max no. threads
nthr = ''
if app.args.nthreads:
    nthr = ' -nthreads ' + app.args.nthreads

# Set multiband factor
mb = 1
if app.args.mb:
    mb = int(app.args.mb)

# Set OR loss
or_option = ' -mb ' + str(mb) + ' -export_error sliceerror.txt'
if app.args.or_loss:
    or_option += ' -loss ' + app.args.or_loss

# Slice order
motfilt_option = ''
if app.args.sorder:
    p,s = app.args.sorder.split(',')
    motfilt_option += ' -packs ' + p + ' -shift ' + s

# Import fixed slice weights
if app.args.sliceweights:
    run.command('cp ' + path.fromUser(app.args.sliceweights, True) + ' sliceweights0.txt')


# Configuration
class Config:
    def __init__(self, svr=False, recit=5, regit=10, scale=1.):
        self.svr = svr
        self.recit = recit
        self.regit = regit
        self.scale = scale


iters = [Config(False, 3, 10, 3.0),
         Config(False, 3, 10, 2.4),
         Config(True,  3, 10, 1.9),
         Config(True,  3, 10, 1.5),
         Config(True,  3, 10, 1.2),
         Config(True, 10, -1, 1.0)]



# Variable input file name
inputfn = 'in.mif'



#   __________ Function definitions __________

def reconstep(k):
    im = inputfn;
    if k > 0 and app.args.matchintensity:
        im = 'scaled.mif'
        run.command('mrcalc ' + inputfn + (' biasfield.mif -exp -mult' if app.args.matchintensity=='full' else '') + ' imscale.mif -mult ' + im + ' -force')
    rcmd = 'dwirecon ' + im + ' recon-' + str(k) + '.mif -spred spred.mif -maxiter ' + str(iters[k].recit)
    rcmd += reg_option + ssp_option + ' -rf ' + ' -rf '.join(rfs)
    if k>0:
        rcmd += ' -motion motion.txt -weights sliceweights.txt -init recon-' + str(k-1) + '.mif'
    elif app.args.sliceweights:
        rcmd += ' -weights sliceweights0.txt'
    rcmd += ' -force' + nthr
    run.command(rcmd)


def calcoutlierweights():
    import numpy as np
    from sklearn import mixture as mix
    E = np.log(np.loadtxt('sliceerror.txt'))
    med = np.median(E)
    mad = np.median(np.abs(E - med)) * 1.4826
    gmm = mix.GaussianMixture(2, 'spherical', means_init=((med,), (3*med,)), precisions_init=(1/mad, 1/(3*mad)), weights_init=(.9, .1))
    gmm.fit(E.reshape((-1,1)))
    P = gmm.predict_proba(E.reshape((-1,1)))[:,0].reshape(dims[2:4])
    if app.args.sliceweights:
        W0 = np.loadtxt('sliceweights0.txt')
        np.savetxt('sliceweights.txt', P*W0)
    else:
        np.savetxt('sliceweights.txt', P)


def sliceweightstep(k):
    mask_opt = ' -mask mask.mif' + (' -motion motion.txt' if k>0 else '')
    if app.args.matchintensity:
        run.command('dwisliceoutliers ' + inputfn + ' spred.mif' + mask_opt + ' sliceweights.txt' + or_option + ' -imscale imscale.mif -force')
        if app.args.matchintensity == 'full':
            run.command('mrcalc spred.mif -abs -log in.mif -abs -log -sub - ' +
                        '| mrfilter - smooth - -stdev 5,5,0 -extent 45,45,1 | mrcalc - biasfield.mif -force')
            run.command('mrcalc biasfield.mif mask.mif -mult - | mrmath -axis 0 - sum - | mrmath -axis 1 - sum tmp1.mif -force')
            run.command('mrmath -axis 0 mask.mif sum - | mrmath -axis 1 - sum tmp2.mif -force')
            run.command('mrcalc biasfield.mif tmp2.mif 0 -eq 0 tmp1.mif tmp2.mif -divide -if -sub - | mrconvert - biasfield.mif -force')
    else:
        run.command('dwisliceoutliers ' + inputfn + ' spred.mif' + mask_opt + ' sliceweights.txt' + or_option + ' -force')
    calcoutlierweights()


def basisupdatestep(k):
    run.command('msshsvd recon-' + str(k) + '.mif -mask mask.mif -lmax ' + ','.join([str(l) for l in sorted(lmax)[::-1]]) +
                (' -lbreg ' + app.args.lbreg if app.args.lbreg else '') + ' ' + ' '.join(rfs) + ' -force')


def rankreduxstep(k, scale=1.):
    run.command('mrfilter recon-' + str(k) + '.mif smooth - -fwhm ' + str(round(vu*scale, 2)) + ' | ' +
                'msshsvd - -mask mask.mif -lmax ' + ','.join([str(l) for l in rlmax]) +
                (' -lbreg ' + app.args.lbreg if app.args.lbreg else '') + ' ' + ' '.join(redrfs) + ' -proj rankredux.mif -force')


def registrationstep(k):
    run.command('dwislicealign ' + inputfn + ' rankredux.mif motion.txt -mask mask.mif -maxiter ' + str(iters[k].regit) +
                ' -mb ' + (str(mb) if iters[k].svr else '0') + (' -init motion.txt' if k>0 else '') +
                ssp_option + ' -force' + nthr)
    if app.args.sorder:
        run.command('motionfilter motion.txt sliceweights.txt motion.txt -medfilt 5 ' + motfilt_option)


def fieldalignstep(k):
    global inputfn
    if app.args.fieldmap:
        if k == 0:
            run.command('mrfieldunwarp in.mif field.mif unwarped.mif')
        else:
            fidx = '-fidx ' + ('0' if not app.args.fieldidx else app.args.fieldidx)
            run.command('mrfieldunwarp in.mif field.mif -motion motion.txt ' + fidx + ' unwarped.mif -force')
        inputfn = 'unwarped.mif'



#   __________ Motion correction __________

# initial template
fieldalignstep(0)
reconstep(0)

# running reconstruction
for k, it in enumerate(iters[:-1]):
    # basis update and rank reduction
    basisupdatestep(k)
    rankreduxstep(k, it.scale)
    # slice weights
    sliceweightstep(k)
    # register template to volumes
    registrationstep(k)
    fieldalignstep(k+1)
    # update template
    reconstep(k+1)


#   __________ Copy outputs __________

run.command('mrconvert recon-'+str(len(iters)-1)+'.mif ' + path.fromUser(app.args.output, True) + (' -force' if app.forceOverwrite else ''))

if app.args.export_motion:
    run.command('cp motion.txt ' + path.fromUser(app.args.export_motion, True))

if app.args.export_weights:
    run.command('cp sliceweights.txt ' + path.fromUser(app.args.export_weights, True))


app.complete()




