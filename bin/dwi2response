#!/usr/bin/env python

# Script for estimating response functions for spherical deconvolution
# A number of different approaches are available within this script for performing response function estimation.



def usage(cmdline): #pylint: disable=unused-variable
  from mrtrix3 import algorithm

  cmdline.set_author('Robert E. Smith (robert.smith@florey.edu.au) and Thijs Dhollander (thijs.dhollander@gmail.com)')
  cmdline.set_synopsis('Estimate response function(s) for spherical deconvolution')
  cmdline.add_description('dwi2response acts as a \'master\' script for performing various types of response function estimation; a range of different algorithms are available for completing this task. When using this script, the name of the algorithm to be used must appear as the first argument on the command-line after \'dwi2response\'. The subsequent compulsory arguments and options available depend on the particular algorithm being invoked.')
  cmdline.add_description('Each algorithm available also has its own help page, including necessary references; e.g. to see the help page of the \'fa\' algorithm, type \'dwi2response fa\'.')

  # General options
  common_options = cmdline.add_argument_group('Options common to all dwi2response algorithms')
  common_options.add_argument('-shells', help='The b-value shell(s) to use in response function estimation (single value for single-shell response, comma-separated list for multi-shell response)')
  common_options.add_argument('-lmax', help='The maximum harmonic degree(s) of response function estimation (single value for single-shell response, comma-separated list for multi-shell response)')
  common_options.add_argument('-mask', help='Provide an initial mask for response voxel selection')
  common_options.add_argument('-voxels', help='Output an image showing the final voxel selection(s)')
  common_options.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
  common_options.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')
  cmdline.flag_mutually_exclusive_options( [ 'grad', 'fslgrad' ] )

  # Import the command-line settings for all algorithms found in the relevant directory
  algorithm.usage(cmdline)






def execute(): #pylint: disable=unused-variable
  from mrtrix3 import algorithm, image, MRtrixError, path, run

  # Find out which algorithm the user has requested
  alg = algorithm.get_module(app.ARGS.algorithm)

  # Check for prior existence of output files, and grab any input files, used by the particular algorithm
  if app.ARGS.voxels:
    app.check_output_path(app.ARGS.voxels)
  alg.check_output_paths()

  # Sanitise some inputs, and get ready for data import
  if app.ARGS.lmax:
    try:
      lmax = [ int(x) for x in app.ARGS.lmax.split(',') ]
      if any([lmax_value%2 for lmax_value in lmax]):
        raise MRtrixError('Value of lmax must be even')
    except:
      raise MRtrixError('Parameter lmax must be a number')
    if alg.needs_single_shell() and not len(lmax) == 1:
      raise MRtrixError('Can only specify a single lmax value for single-shell algorithms')
  shells_option = ''
  if app.ARGS.shells:
    try:
      shells_values = [ int(round(float(x))) for x in app.ARGS.shells.split(',') ]
    except:
      raise MRtrixError('-shells option should provide a comma-separated list of b-values')
    if alg.needs_single_shell() and not len(shells_values) == 1:
      raise MRtrixError('Can only specify a single b-value shell for single-shell algorithms')
    shells_option = ' -shells ' + app.ARGS.shells
  singleshell_option = ''
  if alg.needs_single_shell():
    singleshell_option = ' -singleshell -no_bzero'

  grad_import_option = ''
  if app.ARGS.grad:
    grad_import_option = ' -grad ' + path.from_user(app.ARGS.grad)
  elif app.ARGS.fslgrad:
    grad_import_option = ' -fslgrad ' + path.from_user(app.ARGS.fslgrad[0]) + ' ' + path.from_user(app.ARGS.fslgrad[1])
  elif 'dw_scheme' not in image.Header(path.from_user(app.ARGS.input, False)).keyval():
    raise MRtrixError('Script requires diffusion gradient table: either in image header, or using -grad / -fslgrad option')

  app.make_scratch_dir()

  # Get standard input data into the scratch directory
  if alg.needs_single_shell() or shells_option:
    app.console('Importing DWI data (' + path.from_user(app.ARGS.input) + ') and selecting b-values...')
    run.command('mrconvert ' + path.from_user(app.ARGS.input) + ' - -strides 0,0,0,1' + grad_import_option + ' | dwiextract - ' + path.to_scratch('dwi.mif') + shells_option + singleshell_option, show=False)
  else: # Don't discard b=0 in multi-shell algorithms
    app.console('Importing DWI data (' + path.from_user(app.ARGS.input) + ')...')
    run.command('mrconvert ' + path.from_user(app.ARGS.input) + ' ' + path.to_scratch('dwi.mif') + ' -strides 0,0,0,1' + grad_import_option, show=False)
  if app.ARGS.mask:
    app.console('Importing mask (' + path.from_user(app.ARGS.mask) + ')...')
    run.command('mrconvert ' + path.from_user(app.ARGS.mask) + ' ' + path.to_scratch('mask.mif') + ' -datatype bit', show=False)

  alg.get_inputs()

  app.goto_scratch_dir()

  if app.ARGS.mask:
    # Check that the brain mask is appropriate
    if image.Header('mask.mif').size()[:3] != image.Header('dwi.mif').size()[:3]:
      raise MRtrixError('Dimensions of provided mask image do not match DWI')
  else:
    app.console('Computing brain mask (dwi2mask)...')
    run.command('dwi2mask dwi.mif mask.mif', show=False)

  if int(image.statistic('mask.mif', 'count', '-mask mask.mif')) == 0:
    raise MRtrixError(('Provided' if app.ARGS.mask else 'Generated') + ' mask image does not contain any voxels')

  # From here, the script splits depending on what estimation algorithm is being used
  alg.execute()






# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys
LIB_FOLDER = os.path.realpath(os.path.join(os.path.dirname(os.path.realpath(inspect.getfile(inspect.currentframe()))), os.pardir, 'lib'))
if not os.path.isdir(LIB_FOLDER):
  sys.stderr.write('Unable to locate MRtrix3 Python libraries')
  sys.exit(1)
sys.path.insert(0, LIB_FOLDER)
# Execute the script
from mrtrix3 import app
app.execute()
