#!/usr/bin/env python

# Script that performs B1 field inhomogeneity correction for a DWI volume series
# Bias field is typically estimated using the mean b=0 image, and subsequently used to correct all volumes


def usage(cmdline): #pylint: disable=unused-variable
  from mrtrix3 import algorithm
  cmdline.set_author('Robert E. Smith (robert.smith@florey.edu.au)')
  cmdline.set_synopsis('Perform B1 field inhomogeneity correction for a DWI volume series')
  common_options = cmdline.add_argument_group('Options common to all dwibiascorrect algorithms')
  common_options.add_argument('-mask', metavar='image', help='Manually provide a mask image for bias field estimation')
  common_options.add_argument('-bias', metavar='image', help='Output the estimated bias field')
  grad_options = cmdline.add_argument_group('Options for providing the DWI gradient table')
  grad_options.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
  grad_options.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')
  cmdline.flag_mutually_exclusive_options( [ 'grad', 'fslgrad' ] )

  # Import the command-line settings for all algorithms found in the relevant directory
  algorithm.usage(cmdline)



def execute(): #pylint: disable=unused-variable
  from mrtrix3 import algorithm, image, MRtrixError, path, run

  # Find out which algorithm the user has requested
  alg = algorithm.get_module(app.ARGS.algorithm)

  app.check_output_path(app.ARGS.output)
  app.check_output_path(app.ARGS.bias)
  alg.check_output_paths()

  app.make_scratch_dir()

  grad_import_option = ''
  if app.ARGS.grad:
    grad_import_option = ' -grad ' + path.from_user(app.ARGS.grad)
  elif app.ARGS.fslgrad:
    grad_import_option = ' -fslgrad ' + path.from_user(app.ARGS.fslgrad[0]) + ' ' + path.from_user(app.ARGS.fslgrad[1])
  run.command('mrconvert ' + path.from_user(app.ARGS.input) + ' ' + path.to_scratch('in.mif') + grad_import_option)
  if app.ARGS.mask:
    run.command('mrconvert ' + path.from_user(app.ARGS.mask) + ' ' + path.to_scratch('mask.mif') + ' -datatype bit')

  alg.get_inputs()

  app.goto_scratch_dir()

  # Make sure it's actually a DWI that's been passed
  dwi_header = image.Header('in.mif')
  if len(dwi_header.size()) != 4:
    raise MRtrixError('Input image must be a 4D image')
  if 'dw_scheme' not in dwi_header.keyval():
    raise MRtrixError('No valid DW gradient scheme provided or present in image header')
  if len(dwi_header.keyval()['dw_scheme']) != dwi_header.size()[3]:
    raise MRtrixError('DW gradient scheme contains different number of entries (' + str(len(dwi_header.keyval()['dw_scheme'])) + ' to number of volumes in DWIs (' + dwi_header.size()[3] + ')')

  # Generate a brain mask if required, or check the mask if provided by the user
  if app.ARGS.mask:
    if not image.match('in.mif', 'mask.mif', 3):
      raise MRtrixError('Provided mask image does not match input DWI')
  else:
    run.command('dwi2mask in.mif mask.mif')

  # From here, the script splits depending on what estimation algorithm is being used
  alg.execute()





# Execute the script
from mrtrix3 import app
app.execute()
