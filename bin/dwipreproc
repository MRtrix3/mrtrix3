#!/usr/bin/env python

# Script for performing DWI pre-processing using FSL 5.0 tools eddy / topup / applytopup

# This script is generally one of the first operations that will be applied to diffusion image data. The precise details of how this image pre-processing takes place depends heavily on the DWI acquisition; specifically, the presence or absence of reversed phase-encoding data for the purposes of EPI susceptibility distortion correction.

# The script is capable of handling a wide range of DWI acquisitions with respect to the design of phase encoding directions. This is dependent upon information regarding the phase encoding being embedded within theimage headers. The relevant information should be captured by MRtrix when importing DICOM images; it should also be the case for BIDS-compatible datasets. If the user expects this information to be present within the image headers, the -rpe_header option must be specified.

# If however such information is not present in the image headers, then it is also possible for the user to manually specify the relevant information regarding phase encoding. This involves the following information:
# * The fundamental acquisition protocol design regarding phase encoding. There are three common acquisition designs that are supported:
#   1. All DWI volumes acquired using the same phase encode parameters, and no additional volumes acquired for the purpose of estimating the inhomogeneity field. In this case, eddy will only perform motion and eddy current distortion correction. This configuration is specified using the -rpe_none option.
#   2. All DWI volumes acquired using the same phase encode parameters; but for the purpose of estimating the inhomogeneity field (and subsequently correcting the resulting distortions in the DWIs), an additional pair (or multiple pairs) of image volumes are acquired, where the first volume(s) has the same phase encoding parameters as the input DWI series, and the second volume(s) has precisely the opposite phase encoding. This configuration is specified using the -rpe_pair option; and the user must additionally provide those images to be used for field estimation using the -se_epi option.
#   3. Every DWI gradient direction is acquired twice: once with one phase encoding configuration, and again using the opposite phase encode direction. The goal here is to combine each pair of images into a single DWI volume per gradient direction, where that recombination takes advantage of the information gained from having two volumes where the signal is distorted in opposite directions in the presence of field inhomogeneity.
# * The (primary) direction of phase encoding. In cases where opposing phase encoding is part of the acquisition protocol (i.e. the reversed phase-encode pair in case 2 above, and all of the DWIs in case 3 above), the -pe_dir option specifies the phase encode direction of the _first_ volume in the relevant volume pair; the second is assumed to be the exact opposite.
# * The total readout time of the EPI acquisition. This affects the magnitude of the image distortion for a given field inhomogeneity. If this information is not provided via the -readout_time option, then a 'sane' default of 0.1s will be assumed. Note that this is not actually expected to influence the estimation of the field; it will result in the field inhomogeneity estimation being scaled by some factor, but as long as it uses the same sane default for the DWIs, the distortion correction should operate as expected.

# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys
lib_folder = os.path.realpath(os.path.join(os.path.dirname(os.path.realpath(inspect.getfile(inspect.currentframe()))), os.pardir, 'lib'))
if not os.path.isdir(lib_folder):
  sys.stderr.write('Unable to locate MRtrix3 Python libraries')
  sys.exit(1)
sys.path.insert(0, lib_folder)

import math
from mrtrix3 import app, file, fsl, image, path, phaseEncoding, run #pylint: disable=redefined-builtin


app.init ('Robert E. Smith (robert.smith@florey.edu.au)',
          'Perform diffusion image pre-processing using FSL\'s eddy tool; including inhomogeneity distortion correction using FSL\'s topup tool if possible')
app.cmdline.addDescription('Note that this script does not perform any explicit registration between images provided to topup via the -se_epi option, and the DWI volumes provided to eddy. In some instances (motion between acquisitions) this can result in erroneous application of the inhomogeneity field during distortion correction. If this could potentially be a problem for your data, a possible solution is to insert the first b=0 DWI volume to be the first volume of the image file provided via the -se_epi option. This will hopefully be addressed within the script itself in a future update.')
app.cmdline.addCitation('', 'Andersson, J. L. & Sotiropoulos, S. N. An integrated approach to correction for off-resonance effects and subject movement in diffusion MR imaging. NeuroImage, 2015, 125, 1063-1078', True)
app.cmdline.addCitation('', 'Smith, S. M.; Jenkinson, M.; Woolrich, M. W.; Beckmann, C. F.; Behrens, T. E.; Johansen-Berg, H.; Bannister, P. R.; De Luca, M.; Drobnjak, I.; Flitney, D. E.; Niazy, R. K.; Saunders, J.; Vickers, J.; Zhang, Y.; De Stefano, N.; Brady, J. M. & Matthews, P. M. Advances in functional and structural MR image analysis and implementation as FSL. NeuroImage, 2004, 23, S208-S219', True)
app.cmdline.addCitation('If performing recombination of diffusion-weighted volume pairs with opposing phase encoding directions', 'Skare, S. & Bammer, R. Jacobian weighting of distortion corrected EPI data. Proceedings of the International Society for Magnetic Resonance in Medicine, 2010, 5063', True)
app.cmdline.addCitation('If performing EPI susceptibility distortion correction', 'Andersson, J. L.; Skare, S. & Ashburner, J. How to correct susceptibility distortions in spin-echo echo-planar images: application to diffusion tensor imaging. NeuroImage, 2003, 20, 870-888', True)
app.cmdline.add_argument('input',  help='The input DWI series to be corrected')
app.cmdline.add_argument('output', help='The output corrected image series')
grad_export_options = app.cmdline.add_argument_group('Options for exporting the diffusion gradient table')
grad_export_options.add_argument('-export_grad_mrtrix', metavar='grad', help='Export the final gradient table in MRtrix format')
grad_export_options.add_argument('-export_grad_fsl', nargs=2, metavar=('bvecs', 'bvals'), help='Export the final gradient table in FSL bvecs/bvals format')
app.cmdline.flagMutuallyExclusiveOptions( [ 'export_grad_mrtrix', 'export_grad_fsl' ] )
grad_import_options = app.cmdline.add_argument_group('Options for importing the diffusion gradient table')
grad_import_options.add_argument('-grad', help='Provide a gradient table in MRtrix format')
grad_import_options.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Provide a gradient table in FSL bvecs/bvals format')
app.cmdline.flagMutuallyExclusiveOptions( [ 'grad', 'fslgrad' ] )
options = app.cmdline.add_argument_group('Other options for the dwipreproc script')
options.add_argument('-pe_dir', metavar=('PE'), help='Manually specify the phase encoding direction of the input series; can be a signed axis number (e.g. -0, 1, +2), an axis designator (e.g. RL, PA, IS), or NIfTI axis codes (e.g. i-, j, k)')
options.add_argument('-readout_time', metavar=('time'), type=float, help='Manually specify the total readout time of the input series (in seconds)')
options.add_argument('-se_epi', metavar=('file'), help='Provide an additional image series consisting of spin-echo EPI images, which is to be used exclusively by topup for estimating the inhomogeneity field (i.e. it will not form part of the output image series)')
options.add_argument('-json_import', metavar=('JSON_file'), help='Import image header information from an associated JSON file (may be necessary to determine phase encoding information)')
options.add_argument('-topup_options', metavar=('TopupOptions'), help='Manually provide additional command-line options to the topup command (provide a string within quotation marks that contains at least one space, even if only passing a single command-line option to topup)')
options.add_argument('-eddy_options', metavar=('EddyOptions'), help='Manually provide additional command-line options to the eddy command (provide a string within quotation marks that contains at least one space, even if only passing a single command-line option to eddy)')
options.add_argument('-cuda', help='Use the CUDA version of eddy (if available)', action='store_true', default=False)
rpe_options = app.cmdline.add_argument_group('Options for specifying the acquisition phase-encoding design; note that one of the -rpe_* options MUST be provided')
rpe_options.add_argument('-rpe_none', action='store_true', help='Specify that no reversed phase-encoding image data is being provided; eddy will perform eddy current and motion correction only')
rpe_options.add_argument('-rpe_pair', action='store_true', help='Specify that a set of images (typically b=0 volumes) will be provided for use in inhomogeneity field estimation only (using the -se_epi option). It is assumed that the FIRST volume(s) of this image has the SAME phase-encoding direction as the input DWIs, and the LAST volume(s) has precisely the OPPOSITE phase encoding')
rpe_options.add_argument('-rpe_all', action='store_true', help='Specify that ALL DWIs have been acquired with opposing phase-encoding; this information will be used to perform a recombination of image volumes (each pair of volumes with the same b-vector but different phase encoding directions will be combined together into a single volume). It is assumed that the SECOND HALF of the volumes in the input DWIs have corresponding diffusion sensitisation directions to the FIRST HALF, but were acquired using precisely the opposite phase-encoding direction')
rpe_options.add_argument('-rpe_header', action='store_true', help='Specify that the phase-encoding information can be found in the image header(s), and that this is the information that the script should use')
app.cmdline.flagMutuallyExclusiveOptions( [ 'rpe_none', 'rpe_pair', 'rpe_all', 'rpe_header' ], True )
app.cmdline.flagMutuallyExclusiveOptions( [ 'rpe_none', 'se_epi' ], False ) # May still technically provide -se_epi even with -rpe_all
app.cmdline.flagMutuallyExclusiveOptions( [ 'rpe_header', 'pe_dir' ], False ) # Can't manually provide phase-encoding direction if expecting it to be in the header
app.cmdline.flagMutuallyExclusiveOptions( [ 'rpe_header', 'readout_time' ], False ) # Can't manually provide readout time if expecting it to be in the header
app.parse()


if app.isWindows():
  app.error('Script cannot run on Windows due to FSL dependency')

image.check3DNonunity(path.fromUser(app.args.input, False))

PE_design = ''
if app.args.rpe_none:
  PE_design = 'None'
elif app.args.rpe_pair:
  PE_design = 'Pair'
  if not app.args.se_epi:
    app.error('If using the -rpe_pair option, the -se_epi option must be used to provide the spin-echo EPI data to be used by topup')
elif app.args.rpe_all:
  PE_design = 'All'
elif app.args.rpe_header:
  PE_design = 'Header'
else:
  app.error('Must explicitly specify phase-encoding acquisition design (even if none)')

fsl_path = os.environ.get('FSLDIR', '')
if not fsl_path:
  app.error('Environment variable FSLDIR is not set; please run appropriate FSL configuration script')

if not PE_design == 'None':
  topup_config_path = os.path.join(fsl_path, 'etc', 'flirtsch', 'b02b0.cnf')
  if not os.path.isfile(topup_config_path):
    app.error('Could not find necessary default config file for FSL\'s topup program\n(expected location: ' + topup_config_path + ')')
  topup_cmd = fsl.exeName('topup')
  applytopup_cmd = fsl.exeName('applytopup')

eddy_cmd = fsl.eddyBinary(app.args.cuda)
fsl_suffix = fsl.suffix()
app.checkOutputPath(app.args.output)

# Export the gradient table to the path requested by the user if necessary
grad_export_option = ''
if app.args.export_grad_mrtrix:
  grad_export_option = ' -export_grad_mrtrix ' + path.fromUser(app.args.export_grad_mrtrix, True)
  app.checkOutputPath(path.fromUser(app.args.export_grad_mrtrix, False))
elif app.args.export_grad_fsl:
  grad_export_option = ' -export_grad_fsl ' + path.fromUser(app.args.export_grad_fsl[0], True) + ' ' + path.fromUser(app.args.export_grad_fsl[1], True)
  app.checkOutputPath(path.fromUser(app.args.export_grad_fsl[0], False))
  app.checkOutputPath(path.fromUser(app.args.export_grad_fsl[1], False))


# Convert all input images into MRtrix format and store in temprary directory first
app.makeTempDir()

grad_option = ''
if app.args.grad:
  grad_option = ' -grad ' + path.fromUser(app.args.grad, True)
elif app.args.fslgrad:
  grad_option = ' -fslgrad ' + path.fromUser(app.args.fslgrad[0], True) + ' ' + path.fromUser(app.args.fslgrad[1], True)
json_option = ''
if app.args.json_import:
  json_option = ' -json_import ' + path.fromUser(app.args.json_import, True)
run.command('mrconvert ' + path.fromUser(app.args.input, True) + ' ' + path.toTemp('dwi.mif', True) + grad_option + json_option)
if app.args.se_epi:
  image.check3DNonunity(path.fromUser(app.args.se_epi, False))
  run.command('mrconvert ' + path.fromUser(app.args.se_epi, True) + ' ' + path.toTemp('se_epi.mif', True))

app.gotoTempDir()



# Get information on the input images, and check their validity
dwi_header = image.Header('dwi.mif')
if not len(dwi_header.size()) == 4:
  app.error('Input DWI must be a 4D image')
num_volumes = dwi_header.size()[3]
app.var(num_volumes)
dwi_pe_scheme = phaseEncoding.getScheme(dwi_header)
if app.args.se_epi:
  se_epi_header = image.Header('se_epi.mif')
  if not len(se_epi_header.size()) == 4:
    app.error('File provided using -se_epi option must contain more than one image volume')
  topup_pe_scheme = phaseEncoding.getScheme(se_epi_header)
if 'dw_scheme' not in dwi_header.keyval():
  app.error('No diffusion gradient table found')
grad = dwi_header.keyval()['dw_scheme']
if not len(grad) == num_volumes:
  app.error('Number of lines in gradient table (' + str(len(grad)) + ') does not match input image (' + str(num_volumes) + ' volumes); check your input data')



# Since we want to access user-defined phase encoding information regardless of whether or not
#   such information is present in the header, let's grab it here
manual_pe_dir = None
if app.args.pe_dir:
  manual_pe_dir = [ float(i) for i in phaseEncoding.direction(app.args.pe_dir) ]
app.var(manual_pe_dir)
manual_trt = None
if app.args.readout_time:
  manual_trt = float(app.args.readout_time)
app.var(manual_trt)


do_topup = (not PE_design == 'None')


def grads_match(one, two):
  # Dot product between gradient directions
  # First, need to check for zero-norm vectors:
  # - If both are zero, skip this check
  # - If one is zero and the other is not, volumes don't match
  # - If neither is zero, test the dot product
  if any([val for val in one[0:3]]):
    if not any([val for val in two[0:3]]):
      return False
    dot_product = one[0]*two[0] + one[1]*two[1] + one[2]*two[2]
    if abs(dot_product) < 0.999:
      return False
  elif any([val for val in two[0:3]]):
    return False
  # b-value
  if abs(one[3]-two[3]) > 10.0:
    return False
  return True


# Manually generate a phase-encoding table for the input DWI based on user input
dwi_manual_pe_scheme = None
topup_manual_pe_scheme = None
auto_trt = 0.1
dwi_auto_trt_warning = False
if manual_pe_dir:

  if manual_trt:
    trt = manual_trt
  else:
    trt = auto_trt
    dwi_auto_trt_warning = True

  # Still construct the manual PE scheme even with 'None' or 'Pair':
  #   there may be information in the header that we need to compare against
  if PE_design == 'None':
    line = list(manual_pe_dir)
    line.append(trt)
    dwi_manual_pe_scheme = [ line ] * num_volumes
    app.var(dwi_manual_pe_scheme)

  # With 'Pair', also need to construct the manual scheme for SE EPIs
  elif PE_design == 'Pair':
    line = list(manual_pe_dir)
    line.append(trt)
    dwi_manual_pe_scheme = [ line ] * num_volumes
    app.var(dwi_manual_pe_scheme)
    num_topup_volumes = se_epi_header.size()[3]
    if num_topup_volumes%2:
      app.error('If using -rpe_pair option, image provided using -se_epi must contain an even number of volumes')
    # Assume that first half of volumes have same direction as series;
    #   second half have the opposite direction
    topup_manual_pe_scheme = [ line ] * int(num_topup_volumes/2)
    line = [ (-i if i else 0.0) for i in manual_pe_dir ]
    line.append(trt)
    topup_manual_pe_scheme.extend( [ line ] * int(num_topup_volumes/2) )
    app.var(topup_manual_pe_scheme)

  # If -rpe_all, need to scan through grad and figure out the pairings
  # This will be required if relying on user-specified phase encode direction
  # It will also be required at the end of the script for the manual recombination
  # Update: The possible permutations of volume-matched acquisition is limited within the
  #   context of the -rpe_all option. In particular, the potential for having more
  #   than one b=0 volume within each half means that it is not possible to permit
  #   arbitrary ordering of those pairs, since b=0 volumes would then be matched
  #   despite having the same phase-encoding direction. Instead, explicitly enforce
  #   that volumes must be matched between the first and second halves of the DWI data.
  elif PE_design == 'All':
    if num_volumes%2:
      app.error('If using -rpe_all option, input image must contain an even number of volumes')
    grads_matched = [ num_volumes ] * num_volumes
    grad_pairs = [ ]
    app.debug('Commencing gradient direction matching; ' + str(num_volumes) + ' volumes')
    for index1 in range(int(num_volumes/2)):
      if grads_matched[index1] == num_volumes: # As yet unpaired
        for index2 in range(int(num_volumes/2), num_volumes):
          if grads_matched[index2] == num_volumes: # Also as yet unpaired
            if grads_match(grad[index1], grad[index2]):
              grads_matched[index1] = index2
              grads_matched[index2] = index1
              grad_pairs.append([index1, index2])
              app.debug('Matched volume ' + str(index1) + ' with ' + str(index2) + ': ' + str(grad[index1]) + ' ' + str(grad[index2]))
              break
        else:
          app.error('Unable to determine matching reversed phase-encode direction volume for DWI volume ' + str(index1))
    if not len(grad_pairs) == num_volumes/2:
      app.error('Unable to determine complete matching DWI volume pairs for reversed phase-encode combination')
    # Construct manual PE scheme here:
    #   Regardless of whether or not there's a scheme in the header, need to have it:
    #   if there's one in the header, want to compare to the manually-generated one
    dwi_manual_pe_scheme = [ ]
    for index in range(0, num_volumes):
      line = list(manual_pe_dir)
      if index >= int(num_volumes/2):
        line = [ (-i if i else 0.0) for i in line ]
      line.append(trt)
      dwi_manual_pe_scheme.append(line)
    app.var(dwi_manual_pe_scheme)

else: # No manual phase encode direction defined

  if not PE_design == 'Header':
    app.error('If not using -rpe_header, phase encoding direction must be provided using the -pe_dir option')



def scheme_dirs_match(one, two):
  for line_one, line_two in zip(one, two):
    if not line_one[0:3] == line_two[0:3]:
      return False
  return True

def scheme_times_match(one, two):
  for line_one, line_two in zip(one, two):
    if abs(line_one[3] - line_two[3]) > 5e-3:
      return False
  return True



# Determine whether or not the phase encoding table generated manually should be used
#   (possibly instead of a table present in the image header)
overwrite_dwi_pe_scheme = False
if dwi_pe_scheme:
  if manual_pe_dir:
    # Compare manual specification to that read from the header;
    #   overwrite & give warning to user if they differ
    # Bear in mind that this could even be the case for -rpe_all;
    #   relying on earlier code having successfully generated the 'appropriate'
    #   PE scheme for the input volume based on the diffusion gradient table
    if not scheme_dirs_match(dwi_pe_scheme, dwi_manual_pe_scheme):
      app.warn('User-defined phase-encoding direction design does not match what is stored in DWI image header; proceeding with user specification')
      overwrite_dwi_pe_scheme = True
  if manual_trt:
    # Compare manual specification to that read from the header
    if not scheme_times_match(dwi_pe_scheme, dwi_manual_pe_scheme):
      app.warn('User-defined total readout time does not match what is stored in DWI image header; proceeding with user specification')
      overwrite_dwi_pe_scheme = True
  if overwrite_dwi_pe_scheme:
    dwi_pe_scheme = dwi_manual_pe_scheme # May be used later for triggering volume recombination
  else:
    dwi_manual_pe_scheme = None # To guarantee that these generated data are never used
else:
  # Nothing in the header; rely entirely on user specification
  if PE_design == 'Header':
    app.error('No phase encoding information found in DWI image header')
  if not manual_pe_dir:
    app.error('No phase encoding information provided either in header or at command-line')
  if dwi_auto_trt_warning:
    app.warn('Total readout time not provided at command-line; assuming sane default of ' + str(auto_trt))
  dwi_pe_scheme = dwi_manual_pe_scheme # May be needed later for triggering volume recombination

# This may be required by -rpe_all for extracting b=0 volumes while retaining phase-encoding information
import_dwi_pe_table_option = ''
if dwi_manual_pe_scheme:
  with open('dwi_manual_pe_scheme.txt', 'w') as f:
    for line in dwi_manual_pe_scheme:
      f.write(' '.join( [ str(value) for value in line ] ) + '\n')
  import_dwi_pe_table_option = ' -import_pe_table dwi_manual_pe_scheme.txt'



# Deal with the phase-encoding of the images to be fed to topup (if applicable)
overwrite_topup_pe_scheme = False
if app.args.se_epi:

  # 3 possible sources of PE information: DWI header, topup image header, command-line
  # Any pair of these may conflict, and any one could be absent

  # Have to switch here based on phase-encoding acquisition design
  if PE_design == 'Pair':
    # Criteria:
    #   * If present in own header, ignore DWI header entirely -
    #     - If also provided at command-line, look for conflict & report
    #     - If not provided at command-line, nothing to do
    #   * If _not_ present in own header:
    #     - If provided at command-line, infer appropriately
    #     - If not provided at command-line, but the DWI header has that information, infer appropriately
    if topup_pe_scheme:
      if manual_pe_dir:
        if not scheme_dirs_match(topup_pe_scheme, topup_manual_pe_scheme):
          app.warn('User-defined phase-encoding direction design does not match what is stored in SE EPI image header; proceeding with user specification')
          overwrite_topup_pe_scheme = True
      if manual_trt:
        if not scheme_times_match(topup_pe_scheme, topup_manual_pe_scheme):
          app.warn('User-defined total readout time does not match what is stored in SE EPI image header; proceeding with user specification')
          overwrite_topup_pe_scheme = True
      if overwrite_topup_pe_scheme:
        topup_pe_scheme = topup_manual_pe_scheme
      else:
        topup_manual_pe_scheme = None # To guarantee that these data are never used
    else:
      overwrite_topup_pe_scheme = True
      topup_pe_scheme = topup_manual_pe_scheme

  elif PE_design == 'All':
    # Criteria:
    #   * If present in own header:
    #     - Nothing to do
    #   * If _not_ present in own header:
    #     - Don't have enough information to proceed
    #     - Is this too harsh? (e.g. Have rules by which it may be inferred from the DWI header / command-line)
    if not topup_pe_scheme:
      app.error('If explicitly including SE EPI images when using -rpe_all option, they must come with their own associated phase-encoding information')

  elif PE_design == 'Header':
    # Criteria:
    #   * If present in own header:
    #       Nothing to do (-pe_dir option is mutually exclusive)
    #   * If _not_ present in own header:
    #       Cannot proceed
    if not topup_pe_scheme:
      app.error('No phase-encoding information present in SE EPI image header')

elif not PE_design == 'None': # No SE EPI images explicitly provided: In some cases, can extract appropriate b=0 images from DWI

  # If using 'All' or 'Header', and haven't been given any topup images, need to extract the b=0 volumes from the series,
  #   preserving phase-encoding information while doing so
  # Preferably also make sure that there's some phase-encoding contrast in there...
  # With -rpe_all, need to write inferred phase-encoding to file and import before using dwiextract so that the phase-encoding
  #   of the extracted b=0's is propagated to the generated b=0 series
  run.command('mrconvert dwi.mif' + import_dwi_pe_table_option + ' - | dwiextract - se_epi.mif -bzero')
  se_epi_header = image.Header('se_epi.mif')

  # If there's no contrast remaining in the phase-encoding scheme, it'll be written to
  #   PhaseEncodingDirection and TotalReadoutTime rather than pe_scheme
  # In this scenario, we will be unable to run topup, or volume recombination
  if 'pe_scheme' not in se_epi_header.keyval():
    if PE_design == 'All':
      app.error('DWI header indicates no phase encoding contrast between b=0 images; cannot proceed with volume recombination-based pre-processing')
    else:
      app.warn('DWI header indicates no phase encoding contrast between b=0 images; proceeding without inhomogeneity field estimation')
      do_topup = False
      run.function(os.remove, 'se_epi.mif')
      se_epi_header = None


# This may be required when setting up the topup call
import_topup_pe_table_option = ''
if topup_manual_pe_scheme:
  with open('topup_manual_pe_scheme.txt', 'w') as f:
    for line in topup_manual_pe_scheme:
      f.write(' '.join([str(value) for value in line]) + '\n')
  import_topup_pe_table_option = ' -import_pe_table topup_manual_pe_scheme.txt'


# Need gradient table if running dwi2mask after applytopup to derive a brain mask for eddy
run.command('mrinfo dwi.mif -export_grad_mrtrix grad.b')



eddy_in_topup_option = ''
if do_topup:

  # If no axes need to be cropped, use the original topup input volumes
  # Otherwise, need to call mrcrop with the appropriate options, and pass those to topup
  topup_in_path = 'se_epi.mif'
  # For any non-even axis sizes, crop the first voxel along that dimension
  crop_option = ''
  for axis, axis_size in enumerate(se_epi_header.size()[:3]):
    if int(axis_size)%2:
      crop_option += ' -axis ' + str(axis) + ' 1 ' + str(int(axis_size)-1)
  if crop_option:
    app.warn('Topup images contain at least one non-even dimension; cropping images for topup compatibility')
    run.command('mrcrop se_epi.mif topup_in_crop.mif' + crop_option)
    file.delTemporary('se_epi.mif')
    topup_in_path = 'se_epi_crop.mif'

  # Do the conversion in preparation for topup
  run.command('mrconvert ' + topup_in_path + ' topup_in.nii' + import_topup_pe_table_option + ' -stride -1,+2,+3,+4 -export_pe_table topup_datain.txt')
  file.delTemporary(topup_in_path)

  # Run topup
  topup_manual_options = ''
  if app.args.topup_options:
    topup_manual_options = ' ' + app.args.topup_options.strip()
  run.command(topup_cmd + ' --imain=topup_in.nii --datain=topup_datain.txt --out=field --fout=field_map' + fsl_suffix + ' --config=' + topup_config_path + topup_manual_options)

  # Apply the warp field to the input image series to get an initial corrected volume estimate
  # applytopup can't receive the complete DWI input and correct it as a whole, because the phase-encoding
  #   details may vary between volumes
  if dwi_manual_pe_scheme:
    run.command('mrconvert dwi.mif' + import_dwi_pe_table_option + ' - | mrinfo - -export_pe_eddy applytopup_config.txt applytopup_indices.txt')
  else:
    run.command('mrinfo dwi.mif -export_pe_eddy applytopup_config.txt applytopup_indices.txt')

  # Update: Call applytopup separately for each unique phase-encoding
  # This should be the most compatible option with more complex phase-encoding acquisition designs,
  #   since we don't need to worry about applytopup performing volume recombination
  # Plus, recombination doesn't need to be optimal; we're only using this to derive a brain mask
  applytopup_image_list = [ ]
  index = 1
  with open('applytopup_config.txt', 'r') as f:
    for line in f:
      input_path = 'dwi_pe_' + str(index) + '.nii'
      json_path = 'dwi_pe_' + str(index) + '.json'
      temp_path = 'dwi_pe_' + str(index) + '_topup' + fsl_suffix
      output_path = 'dwi_pe_' + str(index) + '_topup.mif'
      run.command('dwiextract dwi.mif' + import_dwi_pe_table_option + ' -pe ' + ','.join(line.split()) + ' - | mrconvert - ' + input_path + ' -json_export ' + json_path)
      run.command(applytopup_cmd + ' --imain=' + input_path + ' --datain=applytopup_config.txt --inindex=' + str(index) + ' --topup=field --out=' + temp_path + ' --method=jac')
      file.delTemporary(input_path)
      temp_path = fsl.findImage(temp_path)
      run.command('mrconvert ' + temp_path + ' ' + output_path + ' -json_import ' + json_path)
      file.delTemporary(json_path)
      file.delTemporary(temp_path)
      applytopup_image_list.append(output_path)
      index += 1

  # Use the initial corrected volumes to derive a brain mask for eddy
  if len(applytopup_image_list) == 1:
    run.command('dwi2mask ' + applytopup_image_list[0] + ' - | maskfilter - dilate - | mrconvert - mask.nii -datatype float32 -stride -1,+2,+3')
  else:
    run.command('mrcat ' + ' '.join(applytopup_image_list) + ' - | dwi2mask - - | maskfilter - dilate - | mrconvert - mask.nii -datatype float32 -stride -1,+2,+3')

  for entry in applytopup_image_list:
    file.delTemporary(entry)

  eddy_in_topup_option = ' --topup=field'

else:

  # Generate a processing mask for eddy based on the uncorrected input DWIs
  run.command('dwi2mask dwi.mif - | maskfilter - dilate - | mrconvert - mask.nii -datatype float32 -stride -1,+2,+3')



# Run eddy
run.command('mrconvert dwi.mif' + import_dwi_pe_table_option + ' dwi.nii -stride -1,+2,+3,+4 -export_grad_fsl bvecs bvals -export_pe_eddy eddy_config.txt eddy_indices.txt')
file.delTemporary('dwi.mif')
eddy_manual_options = ''
if app.args.eddy_options:
  eddy_manual_options = ' ' + app.args.eddy_options.strip()
run.command(eddy_cmd + ' --imain=dwi.nii --mask=mask.nii --acqp=eddy_config.txt --index=eddy_indices.txt --bvecs=bvecs --bvals=bvals' + eddy_in_topup_option + eddy_manual_options + ' --out=dwi_post_eddy')



# Get the axis strides from the input series, so the output image can be modified to match
stride_option = ' -stride ' + ','.join([str(i) for i in dwi_header.stride()])



# Check to see whether or not eddy has provided a rotated bvecs file;
#   if it has, import this into the output image
bvecs_path = 'dwi_post_eddy.eddy_rotated_bvecs'
if not os.path.isfile(bvecs_path):
  app.warn('eddy has not provided rotated bvecs file; using original gradient table. Recommend updating FSL eddy to version 5.0.9 or later.')
  bvecs_path = 'bvecs'



# Determine whether or not volume recombination should be performed
# This could be either due to use of -rpe_all option, or just due to the data provided with -rpe_header
# Rather than trying to re-use the code that was used in the case of -rpe_all, run fresh code
# The phase-encoding scheme needs to be checked also
volume_matchings = [ num_volumes ] * num_volumes
volume_pairs = [ ]
app.debug('Commencing gradient direction matching; ' + str(num_volumes) + ' volumes')
for index1 in range(num_volumes):
  if volume_matchings[index1] == num_volumes: # As yet unpaired
    for index2 in range(index1+1, num_volumes):
      if volume_matchings[index2] == num_volumes: # Also as yet unpaired
        # Here, need to check both gradient matching and reversed phase-encode direction
        if not any(dwi_pe_scheme[index1][i] + dwi_pe_scheme[index2][i] for i in range(0,3)) and grads_match(grad[index1], grad[index2]):
          volume_matchings[index1] = index2
          volume_matchings[index2] = index1
          volume_pairs.append([index1, index2])
          app.debug('Matched volume ' + str(index1) + ' with ' + str(index2) + '\n' +
                    'Phase encoding: ' + str(dwi_pe_scheme[index1]) + ' ' + str(dwi_pe_scheme[index2]) + '\n' +
                    'Gradients: ' + str(grad[index1]) + ' ' + str(grad[index2]))
          break


if not len(volume_pairs) == int(num_volumes/2):

  # Convert the resulting volume to the output image, and re-insert the diffusion encoding
  run.command('mrconvert ' + fsl.findImage('dwi_post_eddy') + ' result.mif' + stride_option + ' -fslgrad ' + bvecs_path + ' bvals')

else:
  app.console('Detected matching DWI volumes with opposing phase encoding; performing explicit volume recombination')

  # Perform a manual combination of the volumes output by eddy, since LSR is disabled

  # Generate appropriate bvecs / bvals files
  # Particularly if eddy has provided rotated bvecs, since we're combining two volumes into one that
  #   potentially have subject rotation between them (and therefore the sensitisation direction is
  #   not precisely equivalent), the best we can do is take the mean of the two vectors.
  # Manual recombination of volumes needs to take into account the explicit volume matching

  bvecs = [ [] for axis in range(3) ]
  with open(bvecs_path, 'r') as f:
    for axis, line in enumerate(f):
      bvecs[axis] = line.split()

  bvecs_combined_transpose = [ ]
  bvals_combined = [ ]

  for pair in volume_pairs:
    bvec_sum = [ float(bvecs[0][pair[0]]) + float(bvecs[0][pair[1]]),
                 float(bvecs[1][pair[0]]) + float(bvecs[1][pair[1]]),
                 float(bvecs[2][pair[0]]) + float(bvecs[2][pair[1]]) ]
    norm2 = bvec_sum[0]*bvec_sum[0] + bvec_sum[1]*bvec_sum[1] + bvec_sum[2]*bvec_sum[2]
    # If one diffusion sensitisation gradient direction is reversed with respect to
    #   the other, still want to enable their recombination; but need to explicitly
    #   account for this when averaging the two directions
    if norm2 < 0.0:
      bvec_sum = [ float(bvecs[0][pair[0]]) - float(bvecs[0][pair[1]]),
                   float(bvecs[1][pair[0]]) - float(bvecs[1][pair[1]]),
                   float(bvecs[2][pair[0]]) - float(bvecs[2][pair[1]]) ]
      norm2 = bvec_sum[0]*bvec_sum[0] + bvec_sum[1]*bvec_sum[1] + bvec_sum[2]*bvec_sum[2]
    # Occasionally a bzero volume can have a zero vector
    if norm2:
      factor = 1.0 / math.sqrt(norm2)
      new_vec = [ bvec_sum[0]*factor, bvec_sum[1]*factor, bvec_sum[2]*factor ]
    else:
      new_vec = [ 0.0, 0.0, 0.0 ]
    bvecs_combined_transpose.append(new_vec)
    bvals_combined.append(0.5 * (grad[pair[0]][3] + grad[pair[1]][3]))

  with open('bvecs_combined', 'w') as f:
    for axis in range(0, 3):
      axis_data = [ ]
      for volume in range(0, int(num_volumes/2)):
        axis_data.append(str(bvecs_combined_transpose[volume][axis]))
      f.write(' '.join(axis_data) + '\n')

  with open('bvals_combined', 'w') as f:
    f.write(' '.join( [ str(b) for b in bvals_combined ] ))



  # Prior to 5.0.8, a bug resulted in the output field map image from topup having an identity transform,
  #   regardless of the transform of the input image
  # Detect this, and manually replace the transform if necessary
  #   (even if this doesn't cause an issue with the subsequent mrcalc command, it may in the future, it's better for
  #   visualising the script temporary files, and it gives the user a warning about an out-of-date FSL)
  field_map_image = fsl.findImage('field_map')
  if not image.match('topup_in.nii', field_map_image):
    app.warn('topup output field image has erroneous header; recommend updating FSL to version 5.0.8 or later')
    run.command('mrtransform ' + field_map_image + ' -replace topup_in.nii field_map_fix.mif')
    file.delTemporary(field_map_image)
    field_map_image = 'field_map_fix.mif'



  # Derive the weight images
  # Scaling term for field map is identical to the bandwidth provided in the topup config file
  #   (converts Hz to pixel count; that way a simple image gradient can be used to get the Jacobians)
  # Let mrfilter apply the default 1 voxel size gaussian smoothing filter before calculating the field gradient
  #
  #   The jacobian image may be different for any particular volume pair
  #   The appropriate PE directions and total readout times can be acquired from the eddy-style config/index files
  #   eddy_config.txt and eddy_indices.txt

  eddy_config  = [ [ float(f) for f in line.split() ] for line in open('eddy_config.txt', 'r').read().split('\n')[:-1] ]
  eddy_indices = [ int(i) for i in open('eddy_indices.txt', 'r').read().split() ]
  app.var(eddy_config)
  app.var(eddy_indices)

  # This section derives, for each phase encoding configuration present, the 'weight' to be applied
  #   to the image during volume recombination, which is based on the Jacobian of the field in the
  #   phase encoding direction
  for index, config in enumerate(eddy_config):
    pe_axis = [ i for i, e in enumerate(config[0:3]) if e != 0][0]
    sign_multiplier = ' -1.0 -mult' if config[pe_axis] < 0 else ''
    field_derivative_path = 'field_deriv_pe_' + str(index+1) + '.mif'
    run.command('mrcalc ' + field_map_image + ' ' + str(config[3]) + ' -mult' + sign_multiplier + ' - | mrfilter - gradient - | mrconvert - ' + field_derivative_path + ' -coord 3 ' + str(pe_axis) + ' -axes 0,1,2')
    jacobian_path = 'jacobian_' + str(index+1) + '.mif'
    run.command('mrcalc 1.0 ' + field_derivative_path + ' -add 0.0 -max ' + jacobian_path)
    file.delTemporary(field_derivative_path)
    run.command('mrcalc ' + jacobian_path + ' ' + jacobian_path + ' -mult weight' + str(index+1) + '.mif')
    file.delTemporary(jacobian_path)

  # If eddy provides its main image output in a compressed format, the code block below will need to
  #   uncompress that image independently for every volume pair. Instead, if this is the case, let's
  #   convert it to an uncompressed format before we do anything with it.
  eddy_output = fsl.findImage('dwi_post_eddy')
  if eddy_output.endswith('.gz'):
    run.command('mrconvert ' + eddy_output + ' dwi_post_eddy.nii')
    file.delTemporary(eddy_output)
    eddy_output = 'dwi_post_eddy.nii'

  # This section extracts the two volumes corresponding to each reversed phase-encoded volume pair, and
  #   derives a single image volume based on the recombination equation
  combined_image_list = [ ]
  progress = app.progressBar('Performing explicit volume recombination', len(volume_pairs))
  for index, volumes in enumerate(volume_pairs):
    pe_indices = [ eddy_indices[i] for i in volumes ]
    run.command('mrconvert ' + eddy_output + ' volume0.mif -coord 3 ' + str(volumes[0]))
    run.command('mrconvert ' + eddy_output + ' volume1.mif -coord 3 ' + str(volumes[1]))
    # Volume recombination equation described in Skare and Bammer 2010
    run.command('mrcalc volume0.mif weight' + str(pe_indices[0]) + '.mif -mult volume1.mif weight' + str(pe_indices[1]) + '.mif -mult -add weight' + str(pe_indices[0]) + '.mif weight' + str(pe_indices[1]) + '.mif -add -divide 0.0 -max combined' + str(index) + '.mif')
    combined_image_list.append('combined' + str(index) + '.mif')
    run.function(os.remove, 'volume0.mif')
    run.function(os.remove, 'volume1.mif')
    progress.increment()
  progress.done()
  file.delTemporary(eddy_output)

  for index in range(0, len(eddy_config)):
    file.delTemporary('weight' + str(index+1) + '.mif')

  # Finally the recombined volumes must be concatenated to produce the resulting image series
  run.command('mrcat ' + ' '.join(combined_image_list) + ' - -axis 3 | mrconvert - result.mif -fslgrad bvecs_combined bvals_combined' + stride_option)

  for entry in combined_image_list:
    file.delTemporary(entry)




# Finish!
run.command('mrconvert result.mif ' + path.fromUser(app.args.output, True) + grad_export_option + (' -force' if app.forceOverwrite else ''))
app.complete()
